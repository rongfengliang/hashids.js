{"version":3,"file":"hashids.js","mappings":"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","sources":["webpack://Hashids/webpack/universalModuleDefinition","webpack://Hashids/webpack/bootstrap","webpack://Hashids/webpack/runtime/define property getters","webpack://Hashids/webpack/runtime/hasOwnProperty shorthand","webpack://Hashids/./src/util.ts","webpack://Hashids/./src/hashids.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Hashids\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Hashids\"] = factory();\n\telse\n\t\troot[\"Hashids\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","export type NumberLike = bigint | number\n\nexport const keepUnique = <T>(content: Iterable<T>): T[] => [\n  ...new Set(content),\n]\nexport function onlyUnique(value:any, index:number, self:any[]) {\n  return self.indexOf(value) === index;\n}\nexport const withoutChars = (\n  chars: string[],\n  charsToExclude: string[],\n): string[] => chars.filter((char) => !charsToExclude.includes(char))\n\nexport const onlyChars = (chars: string[], keepChars: string[]): string[] =>\n  chars.filter((char) => keepChars.includes(char))\n\nexport const isIntegerNumber = (n: NumberLike | string) =>\n  typeof n === 'bigint' ||\n  (!Number.isNaN(Number(n)) && Math.floor(Number(n)) === n)\n\nexport const isPositiveAndFinite = (n: NumberLike) =>\n  typeof n === 'bigint' || (n >= 0 && Number.isSafeInteger(n))\n\nexport function shuffle(\n  alphabetChars: string[],\n  saltChars: string[],\n): string[] {\n  if (saltChars.length === 0) {\n    return alphabetChars\n  }\n\n  let integer: number\n  const transformed = [...alphabetChars]\n\n  for (let i = transformed.length - 1, v = 0, p = 0; i > 0; i--, v++) {\n    v %= saltChars.length\n    // eslint-disable-next-line no-multi-assign\n    p += integer = saltChars[v].codePointAt(0)!\n    const j = (integer + v + p) % i\n\n    // swap characters at positions i and j\n    const a = transformed[i]\n    const b = transformed[j]\n    transformed[j] = a\n    transformed[i] = b\n  }\n\n  return transformed\n}\n\nexport const toAlphabet = (\n  input: NumberLike,\n  alphabetChars: string[],\n): string[] => {\n  const id: string[] = []\n  let value = input\n\n  if (typeof value === 'bigint') {\n    const alphabetLength = BigInt(alphabetChars.length)\n    do {\n      id.unshift(alphabetChars[Number(value % alphabetLength)])\n      value /= alphabetLength\n    } while (value > BigInt(0))\n  } else {\n    do {\n      id.unshift(alphabetChars[value % alphabetChars.length])\n      value = Math.floor(value / alphabetChars.length)\n    } while (value > 0)\n  }\n\n  return id\n}\n\nexport const fromAlphabet = (\n  inputChars: string[],\n  alphabetChars: string[],\n): NumberLike =>\n  inputChars.reduce<NumberLike>((carry, item) => {\n    const index = alphabetChars.indexOf(item)\n    if (index === -1) {\n      throw new Error(\n        `The provided ID (${inputChars.join(\n          '',\n        )}) is invalid, as it contains characters that do not exist in the alphabet (${alphabetChars.join(\n          '',\n        )})`,\n      )\n    }\n    if (typeof carry === 'bigint') {\n      return carry * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    const value = carry * alphabetChars.length + index\n    const isSafeValue = Number.isSafeInteger(value)\n    if (isSafeValue) {\n      return value\n    }\n    if (typeof BigInt === 'function') {\n      return BigInt(carry) * BigInt(alphabetChars.length) + BigInt(index)\n    }\n    // we do not have support for BigInt:\n    throw new Error(\n      `Unable to decode the provided string, due to lack of support for BigInt numbers in the current environment`,\n    )\n  }, 0)\n\nconst safeToParseNumberRegExp = /^\\+?\\d+$/\n\nexport const safeParseInt10 = (str: string) =>\n  safeToParseNumberRegExp.test(str) ? Number.parseInt(str, 10) : Number.NaN\n\nexport const splitAtIntervalAndMap = <T>(\n  str: string,\n  nth: number,\n  map: (n: string) => T,\n): T[] =>\n  Array.from<never, T>({ length: Math.ceil(str.length / nth) }, (_, index) =>\n    map(str.slice(index * nth, (index + 1) * nth)),\n  )\n\nexport const makeAnyOfCharsRegExp = (chars: string[]) =>\n  new RegExp(\n    chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('|'),\n  )\n\nexport const makeAtLeastSomeCharRegExp = (chars: string[]) =>\n  new RegExp(\n    `^[${chars\n      .map((char) => escapeRegExp(char))\n      // we need to sort these from longest to shortest,\n      // as they may contain multibyte unicode characters (these should come first)\n      .sort((a, b) => b.length - a.length)\n      .join('')}]+$`,\n  )\n\nconst escapeRegExp = (text: string) =>\n  text.replace(/[\\s#$()*+,.?[\\\\\\]^{|}-]/g, '\\\\$&')\n","import type { NumberLike } from './util'\nimport {\n  fromAlphabet,\n  isIntegerNumber,\n  isPositiveAndFinite,\n  makeAnyOfCharsRegExp,\n  makeAtLeastSomeCharRegExp,\n  onlyChars,\n  safeParseInt10,\n  shuffle,\n  splitAtIntervalAndMap,\n  toAlphabet,\n  withoutChars,\n  onlyUnique\n} from './util'\n\nconst MIN_ALPHABET_LENGTH = 16\nconst SEPARATOR_DIV = 3.5\nconst GUARD_DIV = 12\nconst HEXADECIMAL = 16\nconst SPLIT_AT_EVERY_NTH = 12\n\nconst MODULO_PART = 100\nexport default class Hashids {\n  private alphabet: string[]\n  private seps: string[]\n  private guards: string[]\n  private salt: string[]\n  private guardsRegExp: RegExp\n  private sepsRegExp: RegExp\n  private allowedCharsRegExp: RegExp\n\n  constructor(\n    salt = '',\n    private minLength = 0,\n    alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890',\n    seps = 'cfhistuCFHISTU',\n  ) {\n    if (typeof minLength !== 'number') {\n      throw new TypeError(\n        `Hashids: Provided 'minLength' has to be a number (is ${typeof minLength})`,\n      )\n    }\n    if (typeof salt !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided 'salt' has to be a string (is ${typeof salt})`,\n      )\n    }\n    if (typeof alphabet !== 'string') {\n      throw new TypeError(\n        `Hashids: Provided alphabet has to be a string (is ${typeof alphabet})`,\n      )\n    }\n\n    const saltChars = Array.from(salt)\n    const alphabetChars = Array.from(alphabet)\n    const sepsChars = Array.from(seps)\n\n    this.salt = saltChars\n\n    const uniqueAlphabet = alphabetChars.filter(onlyUnique)\n\n    if (uniqueAlphabet.length < MIN_ALPHABET_LENGTH) {\n      throw new Error(\n        `Hashids: alphabet must contain at least ${MIN_ALPHABET_LENGTH} unique characters, provided: ${uniqueAlphabet.join(\n          '',\n        )}`,\n      )\n    }\n\n    /** `alphabet` should not contains `seps` */\n    this.alphabet = withoutChars(uniqueAlphabet, sepsChars)\n    /** `seps` should contain only characters present in `alphabet` */\n    const filteredSeps = onlyChars(sepsChars, uniqueAlphabet)\n    this.seps = shuffle(filteredSeps, saltChars)\n\n    let sepsLength\n    let diff\n\n    if (\n      this.seps.length === 0 ||\n      this.alphabet.length / this.seps.length > SEPARATOR_DIV\n    ) {\n      sepsLength = Math.ceil(this.alphabet.length / SEPARATOR_DIV)\n\n      if (sepsLength > this.seps.length) {\n        diff = sepsLength - this.seps.length\n        this.seps.push(...this.alphabet.slice(0, diff))\n        this.alphabet = this.alphabet.slice(diff)\n      }\n    }\n\n    this.alphabet = shuffle(this.alphabet, saltChars)\n    const guardCount = Math.ceil(this.alphabet.length / GUARD_DIV)\n\n    if (this.alphabet.length < 3) {\n      this.guards = this.seps.slice(0, guardCount)\n      this.seps = this.seps.slice(guardCount)\n    } else {\n      this.guards = this.alphabet.slice(0, guardCount)\n      this.alphabet = this.alphabet.slice(guardCount)\n    }\n\n    this.guardsRegExp = makeAnyOfCharsRegExp(this.guards)\n    this.sepsRegExp = makeAnyOfCharsRegExp(this.seps)\n    this.allowedCharsRegExp = makeAtLeastSomeCharRegExp([\n      ...this.alphabet,\n      ...this.guards,\n      ...this.seps,\n    ])\n  }\n\n  encode(numbers: NumberLike[] | string[] | string): string\n  encode(...numbers: NumberLike[]): string\n  encode(...numbers: string[]): string\n  encode<T extends NumberLike | string>(\n    first: T | T[],\n    ...inputNumbers: T[]\n  ): string {\n    const ret = ''\n\n    let numbers: T[] = Array.isArray(first)\n      ? first\n      : [...(first != null ? [first] : []), ...inputNumbers]\n\n    if (numbers.length === 0) {\n      return ret\n    }\n\n    if (!numbers.every(isIntegerNumber)) {\n      numbers = numbers.map((n) =>\n        typeof n === 'bigint' || typeof n === 'number'\n          ? n\n          : safeParseInt10(String(n)),\n      ) as T[]\n    }\n\n    if (!(numbers as NumberLike[]).every(isPositiveAndFinite)) {\n      return ret\n    }\n\n    return this._encode(numbers as number[]).join('')\n  }\n\n  decode(id: string): NumberLike[] {\n    if (!id || typeof id !== 'string' || id.length === 0) return []\n    return this._decode(id)\n  }\n\n  /**\n   * @description Splits a hex string into groups of 12-digit hexadecimal numbers,\n   * then prefixes each with '1' and encodes the resulting array of numbers\n   *\n   * Encoding '00000000000f00000000000f000f' would be the equivalent of:\n   * Hashids.encode([0x100000000000f, 0x100000000000f, 0x1000f])\n   *\n   * This means that if your environment supports BigInts,\n   * you will get different (shorter) results if you provide\n   * a BigInt representation of your hex and use `encode` directly, e.g.:\n   * Hashids.encode(BigInt(`0x${hex}`))\n   *\n   * To decode such a representation back to a hex string, use the following snippet:\n   * Hashids.decode(id)[0].toString(16)\n   */\n  encodeHex(inputHex: bigint | string): string {\n    let hex = inputHex\n    switch (typeof hex) {\n      case 'bigint':\n        hex = hex.toString(HEXADECIMAL)\n        break\n      case 'string':\n        if (!/^[\\dA-Fa-f]+$/.test(hex)) return ''\n        break\n      default:\n        throw new Error(\n          `Hashids: The provided value is neither a string, nor a BigInt (got: ${typeof hex})`,\n        )\n    }\n\n    const numbers = splitAtIntervalAndMap(hex, SPLIT_AT_EVERY_NTH, (part) =>\n      Number.parseInt(`1${part}`, 16),\n    )\n    return this.encode(numbers)\n  }\n\n  decodeHex(id: string): string {\n    return this.decode(id)\n      .map((number) => number.toString(HEXADECIMAL).slice(1))\n      .join('')\n  }\n\n  isValidId(id: string): boolean {\n    return this.allowedCharsRegExp.test(id)\n  }\n\n  private _encode(numbers: NumberLike[]): string[] {\n    let { alphabet } = this\n\n    const numbersIdInt = numbers.reduce<number>(\n      (last, number, i) =>\n        last +\n        (typeof number === 'bigint'\n          ? Number(number % BigInt(i + MODULO_PART))\n          : number % (i + MODULO_PART)),\n      0,\n    )\n\n    let ret: string[] = [alphabet[numbersIdInt % alphabet.length]]\n    const lottery = [...ret]\n\n    const { seps } = this\n    const { guards } = this\n\n    numbers.forEach((number, i) => {\n      const buffer = lottery.concat(this.salt, alphabet)\n\n      alphabet = shuffle(alphabet, buffer)\n      const last = toAlphabet(number, alphabet)\n\n      ret.push(...last)\n\n      if (i + 1 < numbers.length) {\n        const charCode = last[0].codePointAt(0)! + i\n        const extraNumber =\n          typeof number === 'bigint'\n            ? Number(number % BigInt(charCode))\n            : number % charCode\n        ret.push(seps[extraNumber % seps.length])\n      }\n    })\n\n    if (ret.length < this.minLength) {\n      const prefixGuardIndex =\n        (numbersIdInt + ret[0].codePointAt(0)!) % guards.length\n      ret.unshift(guards[prefixGuardIndex])\n\n      if (ret.length < this.minLength) {\n        const suffixGuardIndex =\n          (numbersIdInt + ret[2].codePointAt(0)!) % guards.length\n        ret.push(guards[suffixGuardIndex])\n      }\n    }\n\n    const halfLength = Math.floor(alphabet.length / 2)\n    while (ret.length < this.minLength) {\n      alphabet = shuffle(alphabet, alphabet)\n      ret.unshift(...alphabet.slice(halfLength))\n      ret.push(...alphabet.slice(0, halfLength))\n\n      const excess = ret.length - this.minLength\n      if (excess > 0) {\n        const halfOfExcess = excess / 2\n        ret = ret.slice(halfOfExcess, halfOfExcess + this.minLength)\n      }\n    }\n\n    return ret\n  }\n\n  private _decode(id: string): NumberLike[] {\n    if (!this.isValidId(id)) {\n      throw new Error(\n        `The provided ID (${id}) is invalid, as it contains characters that do not exist in the alphabet (${this.guards.join(\n          '',\n        )}${this.seps.join('')}${this.alphabet.join('')})`,\n      )\n    }\n    const idGuardsArray = id.split(this.guardsRegExp)\n    const splitIndex =\n      idGuardsArray.length === 3 || idGuardsArray.length === 2 ? 1 : 0\n\n    const idBreakdown = idGuardsArray[splitIndex]\n    if (idBreakdown.length === 0) return []\n\n    const lotteryChar = idBreakdown[Symbol.iterator]().next().value as string\n    const idArray = idBreakdown.slice(lotteryChar.length).split(this.sepsRegExp)\n\n    let lastAlphabet: string[] = this.alphabet\n    const result: NumberLike[] = []\n\n    for (const subId of idArray) {\n      const buffer = [lotteryChar, ...this.salt, ...lastAlphabet]\n      const nextAlphabet = shuffle(\n        lastAlphabet,\n        buffer.slice(0, lastAlphabet.length),\n      )\n      result.push(fromAlphabet(Array.from(subId), nextAlphabet))\n      lastAlphabet = nextAlphabet\n    }\n\n    // if the result is different from what we'd expect, we return an empty result (malformed input):\n    if (this._encode(result).join('') !== id) return []\n    return result\n  }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","onlyUnique","value","index","indexOf","isIntegerNumber","n","Number","isNaN","Math","floor","isPositiveAndFinite","isSafeInteger","shuffle","alphabetChars","saltChars","length","integer","transformed","i","v","p","codePointAt","j","a","b","fromAlphabet","inputChars","reduce","carry","item","Error","join","BigInt","safeToParseNumberRegExp","makeAnyOfCharsRegExp","chars","RegExp","map","char","escapeRegExp","sort","text","replace","Hashids","constructor","salt","minLength","alphabet","seps","TypeError","Array","from","sepsChars","this","uniqueAlphabet","filter","charsToExclude","includes","filteredSeps","keepChars","sepsLength","diff","ceil","push","slice","guardCount","guards","guardsRegExp","sepsRegExp","allowedCharsRegExp","makeAtLeastSomeCharRegExp","encode","first","inputNumbers","numbers","isArray","every","str","String","test","parseInt","NaN","_encode","decode","id","_decode","encodeHex","inputHex","hex","toString","part","_","decodeHex","number","isValidId","numbersIdInt","last","ret","lottery","forEach","buffer","concat","input","alphabetLength","unshift","toAlphabet","charCode","extraNumber","prefixGuardIndex","suffixGuardIndex","halfLength","excess","halfOfExcess","idGuardsArray","split","idBreakdown","lotteryChar","Symbol","iterator","next","idArray","lastAlphabet","result","subId","nextAlphabet"],"sourceRoot":""}